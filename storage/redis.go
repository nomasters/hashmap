package storage

import (
	"encoding/base64"
	"time"

	"github.com/gomodule/redigo/redis"
)

// Storage Defaults
const (
	defaultRedisAddress = ":6379"
	defaultRedisTTL     = 86400
	maxRedisTTL         = 604800
)

// RedisOptions specific to RedisStorage
type RedisOptions struct {
	endpoint          string
	auth              string
	maxIdle           int
	maxActive         int
	idleTimeout       time.Duration
	wait              bool
	maxConnLifetime   time.Duration
	tls               bool
	dialTLSSkipVerify bool
}

// WithRedisEndpoint takes a string and returns an Option
func WithRedisEndpoint(e string) Option {
	return func(o *Options) {
		o.redis.endpoint = e
	}
}

// WithRedisAuth takes a string and returns an Option
func WithRedisAuth(a string) Option {
	return func(o *Options) {
		o.redis.auth = a
	}
}

// WithRedisMaxIdle takes an int and returns an Option
func WithRedisMaxIdle(m int) Option {
	return func(o *Options) {
		o.redis.maxIdle = m
	}
}

// WithRedisMaxActive takes an int and returns an Option
func WithRedisMaxActive(m int) Option {
	return func(o *Options) {
		o.redis.maxActive = m
	}
}

// WithRedisIdleTimeout takes a time.Duration and returns an Option
func WithRedisIdleTimeout(d time.Duration) Option {
	return func(o *Options) {
		o.redis.idleTimeout = d
	}
}

// WithRedisWait takes a bool and returns an Option
func WithRedisWait(b bool) Option {
	return func(o *Options) {
		o.redis.wait = b
	}
}

// WithRedisMaxConnLifetime takes a bool and returns an Option
func WithRedisMaxConnLifetime(d time.Duration) Option {
	return func(o *Options) {
		o.redis.maxConnLifetime = d
	}
}

// WithRedisTLS takes a bool and returns an Option
func WithRedisTLS(b bool) Option {
	return func(o *Options) {
		o.redis.tls = b
	}
}

// WithRedisDialTLSSkipVerify takes a bool and returns an Option
func WithRedisDialTLSSkipVerify(b bool) Option {
	return func(o *Options) {
		o.redis.dialTLSSkipVerify = b
	}
}

// RedisStore is a struct with methods that conforms to the Storage Interface
type RedisStore struct {
	pool *redis.Pool
}

// NewRedisStore returns a RedisStore with StorageOptions mapped to Redis Pool settings.
// Optionally, if Auth is set, Auth is configured on Dial
func NewRedisStore(options ...Option) *RedisStore {
	o := parseOptions(options...).redis
	if o.endpoint == "" {
		o.endpoint = defaultRedisAddress
	}

	return &RedisStore{
		pool: &redis.Pool{
			MaxIdle:         o.maxIdle,
			MaxActive:       o.maxActive,
			IdleTimeout:     o.idleTimeout,
			Wait:            o.wait,
			MaxConnLifetime: o.maxConnLifetime,
			Dial: func() (redis.Conn, error) {
				c, err := redis.Dial("tcp", o.endpoint, redis.DialUseTLS(o.tls), redis.DialTLSSkipVerify(o.dialTLSSkipVerify))
				if err != nil {
					return nil, err
				}
				if o.auth != "" {
					if _, err := c.Do("AUTH", o.auth); err != nil {
						c.Close()
						return nil, err
					}
				}
				return c, nil
			},
		},
	}
}

// Get method for RedisStore
func (s *RedisStore) Get(key string) ([]byte, error) {
	c := s.pool.Get()
	defer c.Close()
	data, err := redis.String(c.Do("GET", key))
	if err != nil {
		return []byte{}, err
	}
	return base64.StdEncoding.DecodeString(data)
}

// Set method takes a key, value, and options and saves the base64 encoded value to redis. It returns an error
// if one is generated by redis
func (s *RedisStore) Set(key string, value []byte, options ...Option) error {
	o := parseOptions(options...)
	data := base64.StdEncoding.EncodeToString(value)
	ttl := enforceRedisTTLRules(int(o.ttl.Seconds()))
	c := s.pool.Get()
	defer c.Close()
	_, err := c.Do("SET", key, data, "EX", ttl)
	return err
}

// Delete method takes a key string and attempts to delete the key and value from redis. It returns an error.
func (s *RedisStore) Delete(key string) error {
	c := s.pool.Get()
	defer c.Close()
	_, err := c.Do("DEL", key)
	return err
}

// enforceRedisTTLRules takes a ttl in seconds and ensures it exists inside of the min and max allowed.
// a 0 value is set to the defaultRedisTTL value, and a value greater than the max allowed is set to the maxRedisTTL
func enforceRedisTTLRules(ttl int) int {
	if ttl <= 0 {
		return defaultRedisTTL
	}
	if ttl > maxRedisTTL {
		return maxRedisTTL
	}
	return ttl
}
