package storage

import (
	"encoding/base64"
	"encoding/json"
	"time"

	"github.com/gomodule/redigo/redis"
)

const (
	defaultRedisAddress = ":6379"
)

// redisOptions specific to RedisStorage
type redisOptions struct {
	endpoint          string
	auth              string
	maxIdle           int
	maxActive         int
	idleTimeout       time.Duration
	wait              bool
	maxConnLifetime   time.Duration
	tls               bool
	dialTLSSkipVerify bool
}

// RedisOption is used for special Settings in Storage
type RedisOption func(*redisOptions)

// parseRedisOptions takes a arbitrary number of Option funcs and returns a options struct
func parseRedisOptions(opts ...RedisOption) (o redisOptions) {
	for _, option := range opts {
		option(&o)
	}
	return
}

// WithRedisEndpoint takes a string and returns an RedisOption
func WithRedisEndpoint(e string) RedisOption {
	return func(o *redisOptions) {
		o.endpoint = e
	}
}

// WithRedisAuth takes a string and returns an RedisOption
func WithRedisAuth(a string) RedisOption {
	return func(o *redisOptions) {
		o.auth = a
	}
}

// WithRedisMaxIdle takes an int and returns an RedisOption
func WithRedisMaxIdle(m int) RedisOption {
	return func(o *redisOptions) {
		o.maxIdle = m
	}
}

// WithRedisMaxActive takes an int and returns an RedisOption
func WithRedisMaxActive(m int) RedisOption {
	return func(o *redisOptions) {
		o.maxActive = m
	}
}

// WithRedisIdleTimeout takes a time.Duration and returns an RedisOption
func WithRedisIdleTimeout(d time.Duration) RedisOption {
	return func(o *redisOptions) {
		o.idleTimeout = d
	}
}

// WithRedisWait takes a bool and returns an RedisOption
func WithRedisWait(b bool) RedisOption {
	return func(o *redisOptions) {
		o.wait = b
	}
}

// WithRedisMaxConnLifetime takes a bool and returns an RedisOption
func WithRedisMaxConnLifetime(d time.Duration) RedisOption {
	return func(o *redisOptions) {
		o.maxConnLifetime = d
	}
}

// WithRedisTLS takes a bool and returns an RedisOption
func WithRedisTLS(b bool) RedisOption {
	return func(o *redisOptions) {
		o.tls = b
	}
}

// WithRedisDialTLSSkipVerify takes a bool and returns an RedisOption
func WithRedisDialTLSSkipVerify(b bool) RedisOption {
	return func(o *redisOptions) {
		o.dialTLSSkipVerify = b
	}
}

// RedisStore is a struct with methods that conforms to the Storage Interface
type RedisStore struct {
	pool *redis.Pool
}

// NewRedisStore returns a RedisStore with StorageOptions mapped to Redis Pool settings.
// Optionally, if Auth is set, Auth is configured on Dial
func NewRedisStore(opts ...RedisOption) *RedisStore {
	o := parseRedisOptions(opts...)
	if o.endpoint == "" {
		o.endpoint = defaultRedisAddress
	}

	return &RedisStore{
		pool: &redis.Pool{
			MaxIdle:         o.maxIdle,
			MaxActive:       o.maxActive,
			IdleTimeout:     o.idleTimeout,
			Wait:            o.wait,
			MaxConnLifetime: o.maxConnLifetime,
			Dial: func() (redis.Conn, error) {
				c, err := redis.Dial("tcp", o.endpoint, redis.DialUseTLS(o.tls), redis.DialTLSSkipVerify(o.dialTLSSkipVerify))
				if err != nil {
					return nil, err
				}
				if o.auth != "" {
					if _, err := c.Do("AUTH", o.auth); err != nil {
						c.Close()
						return nil, err
					}
				}
				return c, nil
			},
		},
	}
}

// redisVal is the json container that lives in redis and is used by the Get and Set methods
type redisVal struct {
	Payload   string `json:"payload"`
	Timestamp int64  `json:"timestamp"`
}

// Get method for RedisStore
func (s *RedisStore) Get(key string) ([]byte, error) {
	c := s.pool.Get()
	defer c.Close()

	data, err := redis.Bytes(c.Do("GET", key))
	if err != nil {
		return []byte{}, err
	}

	var v redisVal
	if err := json.Unmarshal(data, &v); err != nil {
		return []byte{}, err
	}

	return base64.StdEncoding.DecodeString(v.Payload)
}

// Set method takes a key, value, and options and saves the base64 encoded value to redis. It returns an error
// if one is generated by redis
func (s *RedisStore) Set(key string, value []byte, ttl time.Duration, timestamp time.Time) error {
	v := redisVal{
		Payload:   base64.StdEncoding.EncodeToString(value),
		Timestamp: timestamp.UnixNano(),
	}
	enc, _ := json.Marshal(v)

	// safeSetLua is a lua script that adds a conditional check before setting a key
	safeSetLua := `
		if redis.call("EXISTS", KEYS[1]) == 1 then
			local payload = redis.call("GET", KEYS[1])
			local timestamp = cjson.decode(payload)["timestamp"]
			if timestamp/1000 >= tonumber(ARGV[2])/1000 then
				return nil
			end
		end
		return redis.call("SET", KEYS[1], ARGV[1], "EX", ARGV[3])
		`

	c := s.pool.Get()
	defer c.Close()
	safeSet := redis.NewScript(1, safeSetLua)
	// set key with value if timestamp > current timestamp, and set a 10 second TTL
	reply, err := safeSet.Do(c, key, enc, timestamp.UnixNano(), int(safeTTL(ttl).Seconds()))
	if err != nil {
		return err
	}
	if reply == nil {
		return errInvalidTimestamp
	}
	return nil
}

// Close implements the standard Close method for storage
func (s *RedisStore) Close() error {
	return s.pool.Close()
}
